server:
  port: 8080
  address: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  reactive:
    session:
      cookie:
        secure: false       # requires HTTPS in production. Note: secure: true requires HTTPS. For local dev, you may temporarily set secure: false.
        http-only: true    # prevents JS access
        domain: myproject.local
eureka:
  client:
    serviceUrl:
      defaultZone: http://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC # Replace with your Eureka server address
    fetchRegistry: true
    registerWithEureka: false # Gateway typically doesn't need to register itself if it's only consuming services
  instance:
    preferIpAddress: true # Optional: prefer IP address over hostname for registration
spring:
  application:
    name: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
  main:
    web-application-type: reactive
  cloud:
    gateway:
      routes:
        - id: fountation-user-service
          uri: lb://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC # MY-SERVICE-ID is the application name of your microservice in Eureka
          predicates:
            - Path=/user/** # Define the path predicate for this route
          filters:
            - RemoveRequestHeader=favicon.ico
            - RemoveRequestHeader=default-ui.css
        - id: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
          uri: lb://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC # MY-SERVICE-ID is the application name of your microservice in Eureka
          predicates:
            - Path=/account/** # Define the path predicate for this route
          filters:
            - RemoveRequestHeader=favicon.ico
            - RemoveRequestHeader=default-ui.css
      default-filters:
        - TokenRelay=
      globalcors:
        corsConfigurations:
          '[/**]':
            allowedOrigins:
            - "http://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC"  # Your frontend origin(s)
            allowedMethods:
              - GET
              - POST
              - PUT
              - DELETE
              - OPTIONS
            allowedHeaders: "*"
            allowCredentials: true
            maxAge: 3600
  security:
    oauth2:
      client:
        registration:
          # A unique identifier for your client registration (e.g., 'internal-auth-server')
          auth0:
            client-id: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC # Must be registered in your Auth Server DB/config
            client-secret: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC  # Must match what's in your Auth Server DB/config
            authorization-grant-type: authorization_code
            redirect-uri: http://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
            scope: openid,profile,email
            provider: auth0
            client-name: Auth0
        provider:
          # Matches the registration ID above
          auth0:
            # Point this to the base URL of your OWN Spring Authorization Server application
            #issuer-uri: https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC/
            authorization-uri: https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC?audience=https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
            token-uri: https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
            user-info-uri: https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
            jwk-set-uri: https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC
            issuer-uri: https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC/
      resource-server:
        jwt:
          # Spring Security automatically appends /.well-known/openid-configuration
          # to this URI to discover the JWK set URI needed for validation
          issuer-uri: https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC/
          audiences:
            - https://CCCCCCCCCCCCCCCCCCCCCCCCCCCCCC/
logging:
  level:
    org:
      springframework:
        security:
          oauth2:
            client: DEBUG
        web:
          reactive:
            function:
              client:
                ExchangeFunctions: DEBUG
          server:
            util:
              matcher: INFO